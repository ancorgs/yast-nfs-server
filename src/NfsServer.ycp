/**
 * File:
 *   modules/NfsServer.ycp
 *
 * Module:
 *   Configuration of nfs_server
 *
 * Summary:
 *   NFS server configuration data, I/O functions.
 *
 * Authors:
 *   Martin Vidner <mvidner@suse.cz>
 *
 * $Id$
 *
 */

{
    module "NfsServer";
    textdomain "nfs_server";

    import "Runlevel";
    import "Report";

    /**
     * Should the server be started?
     * If false, the exports file will not be touched.
     */
    global boolean start = false;

    /**
     * @example
     * [
     *   $[
     *     "mountpoint": "/projects",
     *     "allowed": [ "*.local.domain(ro)", "@trusted(rw)"]
     *   ],
     *   $[ ... ],
     *   ...
     * ]
     *
     */
    global list(map) exports = [];

    /**
     * Get all NFS server configuration from a map.
     * When called by nfs_server_auto (preparing autoinstallation data)
     * the map may be empty.
     * @param settings	$["start": "exports":]
     * @return	success
     * @see	exports
     */
    global define boolean Import (map settings) ``{
	if (size (settings) == 0)
	{
	    //Provide defaults for autoinstallation editing:
	    //Leave empty.
	    return true;
	}

	boolean missing = false;
	foreach (`k, ["start", "exports"], ``{
	    if (! haskey (settings, k))
	    {
		y2error ("Missing at Import: '%1'.", k);
		missing = true;
	    }
	});
	if (missing)
	{
	    return false;
	}

	start = lookup (settings, "start", false);
	exports = lookup (settings, "exports", []);
	return true;
    }

    /**
     * Dump the NFS settings to a map, for autoinstallation use.
     * @return	$["start": "exports":]
     * @see	exports
     */
    global define map Export () ``{
	return $[
	    "start": start,
	    "exports": exports,
	    ];
    }

    /**
     * Reads NFS settings from the SCR (.etc.exports)
     * @return true on success
     */
    global define boolean Read () ``{
	start = Runlevel::ServiceEnabled ("nfsserver");
	exports = SCR::Read (.etc.exports);

	return exports != nillist;
    }

    /**
     * Saves NFS server configuration. (exports(5))
     * Creates any missing directories.
     * (No parameters because it is too short to abort)
     * @return true on success
     */
    global define boolean Write () ``{
	if (!start)
	{
	    Runlevel::RunInitScript ("nfsserver", "stop");
	    Runlevel::ServiceAdjust ("nfsserver", "disable");
	}
	else
	{
	    // create missing directories.
	    // implemented as finding one that fails.
	    // the find is a workaround for nonfunctioning break in foreach
	    map fail_entry = find (map entry, exports, ``{
		string directory = entry["mountpoint"]:nil;
		if (SCR::Read (.target.dir, directory) == nil)
		{
		    return ! SCR::Execute (.target.mkdir, directory);
		}
		return false;
	    });
	    if (fail_entry != nil)
	    {
		Report::Error (sformat(_("Unable to create a missing directory:\n%1"), fail_entry["mountpoint"]:nil));
		return false;
	    }

	    // (the backup is now done by the agent)
	    if (! SCR::Write(.etc.exports, exports))
	    {
		// error popup message
		Report::Error (_("Unable to write to /etc/exports.
No changes will be made to the
exported directories.\n"));
		return false;
	    }

	    Runlevel::ServiceAdjust ("portmap", "enable");
	    Runlevel::ServiceAdjust ("nfsserver", "enable");

	    if (Runlevel::ServiceStatus ("portmap") != 0)
	    {
		// portmap must not be started if it is running already (see bug # 9999)
		Runlevel::RunInitScript ("portmap", "start");
	    }
	    Runlevel::RunInitScript ("nfsserver", "restart");

	    if (Runlevel::ServiceStatus ("nfsserver") != 0)
	    {
		// error popup message
		Report::Error (_("Unable to restart the NFS server.
Your changes will be active after reboot.
"));
		return false;
	    }
	}

	// FIXME: return errors from runlevel_adjust, when it produces any
	return true;
    }

  /* The end of the definitions */

}
