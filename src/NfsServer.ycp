/**
 * File:
 *   modules/NfsServer.ycp
 *
 * Module:
 *   Configuration of nfs_server
 *
 * Summary:
 *   NFS server configuration data, I/O functions.
 *
 * Authors:
 *   Martin Vidner <mvidner@suse.cz>
 *
 * $Id$
 *
 */

{
    module "NfsServer";
    textdomain "nfs_server";

    import "Runlevel";
    import "Report";
	import "Summary";

    /**
     * Should the server be started?
     * If false, the exports file will not be touched.
     */
    global boolean start = false;

    /**
     * @example
     * [
     *   $[
     *     "mountpoint": "/projects",
     *     "allowed": [ "*.local.domain(ro)", "@trusted(rw)"]
     *   ],
     *   $[ ... ],
     *   ...
     * ]
     *
     */
    global list(map) exports = [];

    /**
     * Get all NFS server configuration from a map.
     * When called by nfs_server_auto (preparing autoinstallation data)
     * the map may be empty.
     * @param settings	$["start": "exports":]
     * @return	success
     * @see	exports
     */
    global define boolean Import (map settings) ``{
	if (size (settings) == 0)
	{	    
	    return true;
	}

	Set(settings);
	return true;
    }

    /**
     * Set the variables just as is and without complaining
     * @param  settings
     * @return void
     */
    global define void Set (map settings)
	``{
	start = lookup (settings, "start_nfsserver", false);
	exports = lookup (settings, "nfs_exports", []);
	return;	
    }
    

    /**
     * Dump the NFS settings to a map, for autoinstallation use.
     * @return	$["start": "exports":]
     * @see	exports
     */
    global define map Export () ``{
	return $[
	    "start_nfsserver": start,
	    "nfs_exports": exports,
	    ];
    }

    /**
     * Reads NFS settings from the SCR (.etc.exports)
     * @return true on success
     */
    global define boolean Read () ``{
	start = Runlevel::ServiceEnabled ("nfsserver");
	exports = SCR::Read (.etc.exports);

	return exports != nillist;
    }

    /**
     * Saves NFS server configuration. (exports(5))
     * Creates any missing directories.
     * (No parameters because it is too short to abort)
     * @return true on success
     */
    global define boolean Write () ``{
	if (!start)
	{
	    Runlevel::RunInitScript ("nfsserver", "stop");
	    Runlevel::ServiceAdjust ("nfsserver", "disable");
	}
	else
	{
	    // create missing directories.
	    foreach (map entry, exports, ``{
		string directory = entry["mountpoint"]:nil;
		if (SCR::Read (.target.dir, directory) == nil)
		{
		    if (! SCR::Execute (.target.mkdir, directory))
		    {
			// not fatal - write other dirs.
			Report::Warning (sformat(_("Unable to create a missing directory:\n%1"), directory));
		    }
		}
	    });

	    // (the backup is now done by the agent)
	    if (! SCR::Write(.etc.exports, exports))
	    {
		// error popup message
		Report::Error (_("Unable to write to /etc/exports.
No changes will be made to the
exported directories.\n"));
		return false;
	    }

	    Runlevel::ServiceAdjust ("portmap", "enable");
	    Runlevel::ServiceAdjust ("nfsserver", "enable");

	    if (Runlevel::ServiceStatus ("portmap") != 0)
	    {
		// portmap must not be started if it is running already (see bug # 9999)
		Runlevel::RunInitScript ("portmap", "start");
	    }
	    Runlevel::RunInitScript ("nfsserver", "restart");

	    if (Runlevel::ServiceStatus ("nfsserver") != 0)
	    {
		// error popup message
		Report::Error (_("Unable to restart the NFS server.
Your changes will be active after reboot.
"));
		return false;
	    }
	}

	// FIXME: return errors from runlevel_adjust, when it produces any
	return true;
    }


	global define string Summary()``{
		string summary = "";
		summary = Summary::AddHeader(summary, _("NFS Exports"));
		if (size(exports)>0)
		{
			foreach(`e, exports, ``{
					summary = Summary::OpenList(summary);
					summary = Summary::AddListItem(summary,e["mountpoint"]:"");
					summary = Summary::CloseList(summary);
					});
		}
		else
			summary = Summary::AddLine(summary, Summary::NotConfigured());
		return summary;
	}

  /* The end of the definitions */

}
