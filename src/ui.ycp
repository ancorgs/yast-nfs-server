/**
 * File:
 *   ui.ycp
 *
 * Module:
 *   NFS server
 *
 * Summary:
 *   Network NFS server dialogs
 *
 * Authors:
 *   Jan Holesovky <kendy@suse.cz>
 *   Dan Vesely (dan@suse.cz)
 *   Martin Vidner <mvidner@suse.cz>
 *
 * $Id$
 *
 * Network NFS server dialogs
 *
 */

{

    textdomain "nfs_server";

    import "NfsServer";
    import "Wizard";
    include "nfs_server/routines.ycp";
    include "ui/common_popups.ycp";
    include "ui/file_popups.ycp";

    /**
     * The kernel-based server can handle spaces in paths,
     * the user-mode server cannot.
     */
    global boolean spaces_allowed = false;

    /**
     * Ask user for a directory to export. Allow browsing.
     * @param mountpoint	default value
     * @param exports		exports list to check for duplicates
     * @return			a path to export or nil if cancelled
     */
    global define string GetDirectory(string mountpoint, list(map) exports) ``{
	Wizard::SetScreenShotName ("nfs-server-2a-dir");

	if (mountpoint == nil)
	    mountpoint = "";

	UI::OpenDialog(
	    `opt(`decorated),
	    `HBox(
		`HSpacing(1),
		`VBox(
		    `VSpacing(0.2),
		    `HBox (
			`TextEntry(`id(`mpent),
				   // text entry label
				   _("&Directory to export:"), mountpoint),
			`HSpacing (1),
			`VBox (
			    // button label
			    `Bottom(`PushButton (`id (`browse), _("&Browse")))
			    )
			),
		    `VSpacing(0.2),
		    `HBox(
			`PushButton(`id(`ok), `opt(`default), OKButtonLabel()),
			`PushButton(`id(`cancel), CancelButtonLabel())
			),
		    `VSpacing(0.2)),
		`HSpacing(1)
		));
	UI::SetFocus (`id (`mpent));

	any ret = nil;
	do {
	    ret = UI::UserInput();

	    mountpoint = UI::QueryWidget(`id(`mpent), `Value);
	    if (ret == `ok)
	    {
		list allowed = FindAllowed(exports, mountpoint);
		if (allowed != nil) {
		    // error popup message
		    UI::MessagePopup(_("The exports table already
contains this directory."));
		    ret = nil;
		}
		else if (!spaces_allowed && findfirstof (mountpoint, " \t") != nil)
		{
		    UI::MessagePopup(sformat (
// message popup; %1, %2 are package names
_("The user-mode NFS server (%1) cannot export directories
with spaces in their names.
Use the kernel-based server (%2) to do that."), "nfs-server", "nfs-utils"));
		    ret = nil;
		}
		else if (SCR::Read (.target.size, mountpoint) < 0 && !Mode::config) {
		    // the dir does not exist
		    ret = UI::YesNoPopup(_("The directory does not exist.
Create it?")) ? `ok : nil;
		}
	    }
	    else if (ret == `browse)
	    {
		string dir = UI::QueryWidget (`id (`mpent), `Value);
		if (size (dir) == 0)
		{
		    dir = "/";
		}

		dir = PopupDir (dir);

		if (size (dir) > 0)
		{
		    UI::ChangeWidget (`id (`mpent), `Value, dir);
		}

	    }

	} while (ret != `ok && ret != `cancel);

	UI::CloseDialog();
	Wizard::RestoreScreenShotName ();

	if (ret == `ok)
	    return mountpoint;
	return nil;
    }

    /**
     * The kernel based server complains about an empty host specification
     * and wants us to use "*". But the user mode server would match it
     * only with an unqualified name. We must not use "*" there
     * to mean an anonymous client.
     */
    global boolean use_star_for_anonymous = false;

    /**
     * Ask user for an entry for the allowed hosts list.
     * @param hosts	hosts default value
     * @param opts	options default value
     * @param allowed	current list, to check for duplicates
     * @return		[newhosts, newopts] or nil if cancelled. Options without parentheses.
     */
    global define list(string) GetAllowedHosts(string hosts, string opts, list(string) allowed) ``{
	Wizard::SetScreenShotName ("nfs-server-2b-hosts");

	if (hosts == nil)   hosts = "";
	if (opts == nil)    opts = "";
	if (allowed == nil) allowed = [];
	list allowed_names = maplist(`str, allowed, ``{
	    integer brpos = findfirstof(str, "(");
	    if (str != nil)
	    str = substring(str, 0, brpos);
	    return str;
	});

	UI::OpenDialog(`opt(`decorated),
		       `HBox(`HSpacing(1),
			     `VBox(`VSpacing(0.2),
				   // make at least the default options fit
				   `HSpacing (30),
				   // text entry label
				   `TextEntry(`id(`hostsent), _("&Hosts wildcard:"), hosts),
				   // text entry label
				   `TextEntry(`id(`optsent), _("O&ptions:"), opts),
				   `VSpacing(0.2),
				   // ok pushbutton: confirm the dialog
				   `HBox(`PushButton(`id(`ok), `opt(`default), OKButtonLabel()),
					 `PushButton(`id(`cancel), CancelButtonLabel())),
				   `VSpacing(0.2)),
			     `HSpacing(1)
			   ));

	UI::SetFocus (`id (`hostsent));
	any ret = nil;
	do {
	    ret = UI::UserInput();

	    hosts = UI::QueryWidget(`id(`hostsent), `Value);
	    if (use_star_for_anonymous && size (hosts) == 0)
	    {
		hosts = "*";
		UI::ChangeWidget (`id(`hostsent), `Value, hosts);
	    }
	    opts = UI::QueryWidget(`id(`optsent), `Value);
	    opts = deletechars (opts, " ()");
	    UI::ChangeWidget (`id(`optsent), `Value, opts);
	    if (ret == `ok &&
		(!CheckNoSpaces(hosts) || !CheckExportOptions(opts)))
		ret = nil;
	    if (ret == `ok && contains(allowed_names, hosts)) {
		// error popup message
		UI::MessagePopup(_("Options for this wildcard
are already set."));
		ret = nil;
	    }
	} while (ret != `ok && ret != `cancel);

	UI::CloseDialog();
	Wizard::RestoreScreenShotName ();

	if (ret == `ok)
	    return [ hosts, opts ];
	return nil;
    }


    /**
     * Opening NFS server dialog
     * @return `back, `abort, `next `or finish
     */
    global define symbol BeginDialog () ``{
	Wizard::SetScreenShotName ("nfs-server-1-start");

	boolean start_nfs_server = NfsServer::start;

	string help_text =
	// Help, part 1 of 2
_("<P>Here you can choose whether you want to start NFS server on your computer
and export some of your directories to the others.</P>");

	help_text = help_text +
	// Help, part 2 of 2
_("<P>If you choose <B>Start NFS server</B>, the <B>Next</B> button will open
a configuration dialog where you can specify the directories to export.</P>");

	/* The end of the definitions */

	term finish_button = `PushButton (`id (`next), `opt (`default),
					  FinishButtonLabel());

	term contents =
	    `HVSquash(
		// frame label
		`Frame(_("NFS server"),
		       `VBox(`VSpacing(0.2),
			     `RadioButtonGroup(`id(`rbgroup),
				// radio button label
					       `VBox(`Left(`RadioButton(`id(`servyes), `opt (`notify), _("&Start NFS server"), start_nfs_server)),
				//radio button label
						     `Left(`RadioButton(`id(`servno), `opt (`notify), _("&Don't start NFS server"), !start_nfs_server)))),
			     `VSpacing(0.2))));

	// dialog title
	Wizard::SetContents(_("Configuration of the NFS server"),
			      contents, help_text, true, true);

	any ret = nil;
	do {
	    if (!start_nfs_server)
	    {
		//UI::ChangeWidget (`id (`next), `Label, FinishButtonLabel());
		Wizard::ReplaceNextButton (finish_button);
	    }
	    else
	    {
		//UI::ChangeWidget (`id (`next), `Label, NextButtonLabel());
		Wizard::RestoreNextButton ();
		UI::SetFocus(`id(`next));
	    }

	    ret = UI::UserInput ();
	    if (ret == `cancel)
	    {
		ret = `abort;
	    }
	    if (ret == `abort && !UI::ReallyAbortPopup (true))
	    {
		continue;
	    }

	    start_nfs_server = (UI::QueryWidget(`id(`rbgroup), `CurrentButton) == `servyes);
	} while (ret != `back && ret != `next && ret != `abort);

	if (ret == `next)
	{
	    NfsServer::start = start_nfs_server;

	    if (!start_nfs_server)
	    {
		return `finish;
	    }
	}

	Wizard::RestoreScreenShotName ();
	return ret;
    }

    /**
     * Exports dialog itself
     * @return `back, `abort, `next
     */
    global define symbol ExportsDialog () ``{
	Wizard::SetScreenShotName ("nfs-server-2-exports");

	// Help, part 1 of 3
	string help_text = _("<P>The upper box contains all the directories which will be exported.
If a directory is selected, the lower box shows the hosts allowed to
mount this directory.</P>
");

	// Help, part 2 of 3
	help_text = help_text + _("<P>Hosts wildcard sets which hosts can access the selected directory.
It can be <I>single host</I>, <I>netgroups</I>, <I>wildcards</I> or
<I>IP networks</I>.</P>
");

	// Help, part 3 of 3
	help_text = help_text + _("<P>Please have a look at <B>man exports</B> for further information.</P>
");

	list exports = NfsServer::exports;

	term contents =
	    `VBox(
		`ReplacePoint(`id(`exportsrep), ExportsSelBox(exports)),
		// push button label
		`HBox(`PushButton(`id(`mpnewbut), _("Add &directory")),
		      // push button label
		      `PushButton(`id(`mpeditbut), _("&Edit")),
		      // push button label
		      `PushButton(`id(`mpdelbut), _("De&lete"))),
		// push button label
		`VBox(`Left(`Label(`id(`allowedlab), `opt(`hstretch), "")),
		      `Table(`id(`allowedtab), `opt(`notify, `immediate),
			     // table header
			     `header(_("Hosts wildcard")+"  ",
			     // table header
				     _("Options")+"  "),
			     [])),
		      // push button label
		`HBox(`PushButton(`id(`alwnewbut), _("Add &host")),
		      // push button label
		      `PushButton(`id(`alweditbut), _("Ed&it")),
		      // push button label
		      `PushButton(`id(`alwdelbut), _("Dele&te")))
		);

	Wizard::SetContentsButtons (
	    // dialog title
	    _("Directories to export to the others"),
	    contents, help_text,
	    BackButtonLabel (), FinishButtonLabel());

	any ret = nil;
	any simulated = nil; // simulated user input
	string oldmp = nil;
	// preselect an item - convenience, button enabling
	if (size (exports) > 0)
	{
	    UI::ChangeWidget (`id (`exportsbox), `CurrentItem, exports[0,"mountpoint"]:"");
	}
	do {
	    string mountpoint = UI::QueryWidget (`id (`exportsbox), `CurrentItem);
	    boolean anymp = mountpoint != nil;

	    UI::ChangeWidget (`id (`mpeditbut), `Enabled, anymp);
	    UI::ChangeWidget (`id (`mpdelbut), `Enabled, anymp);
	    UI::ChangeWidget (`id (`alwnewbut), `Enabled, anymp);
	    if (mountpoint != oldmp)
	    {
		if (mountpoint == nil)
		{
		    mountpoint = "";
		}
		UI::ChangeWidget (`id(`allowedlab), `Value, mountpoint);
		oldmp = mountpoint;
		list allowed = FindAllowed (exports, mountpoint);
		UI::ChangeWidget(`id (`allowedtab), `Items,
				 AllowedTableItems (allowed != nil? allowed: []));
	    }
	    boolean anyalw = UI::QueryWidget (`id (`allowedtab), `CurrentItem) != nil;
	    UI::ChangeWidget (`id (`alweditbut), `Enabled, anyalw);
	    UI::ChangeWidget (`id (`alwdelbut), `Enabled, anyalw);

	    // Kludge, because a `Table still does not have a shortcut.
	    UI::SetFocus (`id (`allowedtab));

	    // simulated input,
	    // used for `alweditbut afted `mpnewbut
	    if (simulated == nil)
	    {
		ret = UI::UserInput();
		if (ret == `cancel)
		{
		    ret = `abort;
		}
	    }
	    else
	    {
		ret = simulated;
		simulated = nil;
	    }

	    if (ret == `mpnewbut)
	    {
		string mountpoint = GetDirectory(nil, exports);

		if (mountpoint != nil)
		{
		    list default_allowed = [
			sformat ("%1(%2)",
				 use_star_for_anonymous? "*":"",
				 // these are the default anyway
				 // Exportfs of nfs-utils-1.0.1 gives a warning
				 // if neither of sync, async is specified.
				 "ro,root_squash,sync")
			];
		    exports = add(exports, $[ "mountpoint" : mountpoint,
					    "allowed"    : default_allowed ]);
		    UI::ReplaceWidget(`id(`exportsrep), ExportsSelBox(exports));
		    UI::ChangeWidget(`id(`exportsbox), `CurrentItem, mountpoint);
		    simulated = `alweditbut;
		}
	    }
	    else if (ret == `mpeditbut)
	    {
		string mp = UI::QueryWidget(`id(`exportsbox), `CurrentItem);
		if (mp != nil) {
		    string mountpoint = GetDirectory(mp,
						     filter(`ent, exports, ``{
							 return lookup(ent, "mountpoint", "") != mp;
						     }));

		    if (mountpoint != nil) {
			exports = maplist(`ent, exports, ``{
			    string tmp = lookup(ent, "mountpoint", "");
			    if (tmp == mp)
			    return add(ent, "mountpoint", mountpoint);
			    return ent;
			});
			UI::ReplaceWidget(`id(`exportsrep), ExportsSelBox(exports));
			UI::ChangeWidget(`id(`exportsbox), `CurrentItem, mountpoint);
		    }
		}
	    }
	    else if (ret == `mpdelbut)
	    {
		string mountpoint = UI::QueryWidget(`id(`exportsbox), `CurrentItem);
		if (mountpoint != nil)
		    exports = filter(`entry, exports,
				     ``(lookup(entry, "mountpoint", "") != mountpoint));

		UI::ReplaceWidget(`id(`exportsrep), ExportsSelBox(exports));
		if (size (exports) > 0)
		{
		    UI::ChangeWidget (`id (`exportsbox), `CurrentItem,
				      exports[0,"mountpoint"]:"");
		}
	    }
	    else if (ret == `alwnewbut)
	    {
		string mountpoint = UI::QueryWidget(`id(`exportsbox), `CurrentItem);
		if (mountpoint != nil) {
		    list allowed = FindAllowed(exports, mountpoint);

		    list hostopt = GetAllowedHosts(nil, nil, allowed);
		    if (hostopt != nil) {
			allowed = add(allowed, select(hostopt, 0, "")+"("+select(hostopt, 1, "")+")");
			exports = ReplaceInExports(exports, mountpoint, allowed);

			UI::ChangeWidget(`id(`allowedtab), `Items,
					 AllowedTableItems(allowed));
		    }
		}
	    }
	    else if (ret == `alweditbut)
	    {
		string mountpoint = UI::QueryWidget(`id(`exportsbox), `CurrentItem);
		if (mountpoint != nil) {
		    list allowed = FindAllowed(exports, mountpoint);
		    string hosts = "";
		    string opts = "";
		    if (allowed != nil) {
			integer alw_no = UI::QueryWidget(`id(`allowedtab), `CurrentItem);
			if (alw_no != nil) {
			    list(string) ho = AllowedToHostsOpts(select(allowed, alw_no, ""));
			    hosts = select(ho, 0, "");
			    opts = select(ho, 1, "");
			}
			allowed = remove (allowed, alw_no);
		    }
		    list hostopt = GetAllowedHosts(hosts, opts, allowed);
		    if (hostopt != nil) {
			allowed = add(allowed, select(hostopt, 0, "")+"("+select(hostopt, 1, "")+")");
			exports = ReplaceInExports(exports, mountpoint, allowed);

			UI::ChangeWidget(`id(`allowedtab), `Items,
					 AllowedTableItems(allowed));
		    }
		}
	    }
	    else if (ret == `alwdelbut)
	    {
		string mountpoint = UI::QueryWidget(`id(`exportsbox), `CurrentItem);
		if (mountpoint != nil) {
		    list allowed = FindAllowed(exports, mountpoint);
		    integer alwno = UI::QueryWidget(`id(`allowedtab), `CurrentItem);
		    if (allowed != nil && alwno != nil) {
			allowed = remove (allowed, alwno);
			exports = maplist(`entry, exports, ``{
			    if (lookup(entry, "mountpoint", "") == mountpoint)
			    entry = add(entry, "allowed", allowed);
			    return entry;
			});

			UI::ChangeWidget(`id(`allowedtab), `Items,
					 AllowedTableItems(allowed));
		    }
		}
	    }
	    else if (ret == `abort && !UI::ReallyAbortPopup (true))
	    {
		continue;
	    }
	} while (ret != `back && ret != `next && ret != `abort);

	if (ret == `next)
	{
	    NfsServer::exports = exports;
	}

	Wizard::RestoreScreenShotName ();
	return ret;
    }


    /**
     * Last confirmation dialog to use with sequencer
     * @return `back or `finish
     */
    global define symbol SaveDialog () ``{
	Wizard::SetScreenShotName ("nfs-server-3-save");

	// yes-no popup
	string message = _("The entered values will be written now.
Do you really want to use the new settings?");
	symbol ret = `back;

	if (UI::YesNoPopup (message))
	{
	    ret = `finish;
	}

	Wizard::RestoreScreenShotName ();
	return ret;
    }


	/**
	 * Whole configuration of NfsServer but without reading and writing.
	 * For use with autoinstallation.
	 * @return sequence result
	 */
	global define symbol NfsServerAutoSequence() ``{

    map Aliases = $[
    "begin"   : ``(BeginDialog ()),
    "exports"   : ``(ExportsDialog ())
    ];

    map Sequence = $[
    "ws_start"  : "begin",
    "begin"     : $[
	`next   : "exports",
	`finish : `next,
	`abort  : `abort
	],
    "exports"       : $[
	`next   : `next,
	`abort  : `abort
	]
    ];

    Wizard::CreateDialog ();
	symbol ret = WizardSequencer (Aliases, Sequence);
	UI::CloseDialog ();
	return ret;
	}
}
